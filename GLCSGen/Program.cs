/*
 * The MIT License (MIT)
 * Copyright (c) 2013, Nick Gravelyn.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
*/

using System;
using System.Globalization;
using System.IO;
using System.Text;

namespace GLCSGen
{
    // This program assumes it's running via F5 in Visual Studio
    public class Program
    {
        static void Main(string[] args)
        {
            // Walk up to the solution file so we can then go into GL-CS and write to the C# files directly
            DirectoryInfo directory = new DirectoryInfo(Directory.GetCurrentDirectory());
            while (directory != null && !File.Exists(Path.Combine(directory.FullName, "GL-CS.sln")))
            {
                directory = directory.Parent;
            }

            // Now set the directory to the GL-CS folder
            directory = new DirectoryInfo(Path.Combine(directory.FullName, "GL-CS"));

            // Load the spec
            var spec = GLSpec.FromFile("gl.xml");

            //using (var stream = File.Create("spec.xml"))
            //{
            //    var serializer = new XmlSerializer(typeof(GLSpec));
            //    serializer.Serialize(stream, spec);
            //}

            foreach (var version in spec.Versions)
            {
                using (var writer = new CodeWriter(Path.Combine(directory.FullName, version.Name + ".cs")))
                {
                    writer.WriteLine("// This file was autogenerated by GLCSGen on {0}", DateTime.Now);
                    writer.WriteLine("// Original copyright from gl.xml:");
                    foreach (var l in spec.HeaderComment.Split('\n', '\r'))
                    {
                        writer.WriteLine("// {0}", l);
                    }
                    writer.WriteLine();
                    writer.WriteLine("using System;");
                    writer.WriteLine();
                    writer.WriteLine("namespace GL");
                    writer.WriteOpenBrace();
                    writer.WriteLine("public static class {0}", version.Name);
                    writer.WriteOpenBrace();

                    writer.WriteLine("#region Enums");
                    foreach (var e in version.Enums)
                    {
                        string type = IsUint(e.Value) ? "uint" : "ulong";
                        writer.WriteLine("public static {0} {1} = {2};", type, e.Key, e.Value);
                    }
                    writer.WriteLine("#endregion");

                    writer.WriteLine();

                    writer.WriteLine("#region Commands");
                    foreach (var c in version.Commands)
                    {
                        writer.WriteLine("public static {0}Func {0};", c.Name);
                    }
                    writer.WriteLine("#endregion");

                    writer.WriteLine();

                    writer.WriteLine("#region Command Delegates");
                    foreach (var c in version.Commands)
                    {
                        StringBuilder builder = new StringBuilder("public delegate ");
                        builder.Append(ConvertGLType(c.ReturnType));
                        builder.AppendFormat(" {0}Func(", c.Name);
                        
                        foreach (var p in c.Parameters)
                        {
                            var name = p.Name;

                            // Add @ to start of any names that are C# keywords to avoid conflict
                            if (name == "params" || name == "string" || name == "ref" || name == "base")
                            {
                                name = "@" + name;
                            }

                            builder.AppendFormat("{0} {1}, ", ConvertGLType(p.Type), name);
                        }

                        if (c.Parameters.Count > 0)
                        {
                            builder.Length -= 2;
                        }

                        builder.Append(");");

                        writer.WriteLine(builder.ToString());
                    }
                    writer.WriteLine("#endregion");

                    writer.WriteCloseBrace();
                    writer.WriteCloseBrace();
                }
            }
        }

        private static string ConvertGLType(string type)
        {
            if (type == "GLboolean")
            {
                return "bool";
            }
            else if (type == "GLuint" || type == "GLenum" || type == "GLbitfield")
            {
                return "uint";
            }
            else if (type == "GLint" || type == "GLsizei" || type == "GLsizeiptr" || type == "GLfixed" || type == "GLclampx" || type == "GLintptrARB" || type == "GLsizeiptrARB")
            {
                return "int";
            }
            else if (type.Contains("*") || type == "GLsync" || type == "GLintptr" || type == "GLDEBUGPROC")
            {
                return "IntPtr";
            }
            else if (type == "GLfloat" || type == "GLclampf")
            {
                return "float";
            }
            else if (type == "GLdouble")
            {
                return "double";
            }
            else if (type == "GLubyte")
            {
                return "byte";
            }
            else if (type == "GLbyte")
            {
                return "sbyte";
            }
            else if (type == "GLushort")
            {
                return "ushort";
            }
            else if (type == "GLshort")
            {
                return "short";
            }
            else if (type == "GLuint64")
            {
                return "ulong";
            }

            return type;
        }

        private static bool IsUint(string value)
        {
            bool isHex = false;

            if (value.StartsWith("0x"))
            {
                isHex = true;
                value = value.Substring(2);
            }

            uint result;
            if (isHex)
            {
                return uint.TryParse(value, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out result);
            }
            else
            {
                return uint.TryParse(value, out result);
            }
        }
    }
}
